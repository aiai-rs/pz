<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>æ±‡ç›ˆå›½é™… - å®‰å…¨æ‹ç…§æ‰“å¡</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { 
    margin:0; 
    font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
    background:#000; 
    color:#fff; 
    overflow:hidden; 
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #container { 
    position:relative; 
    width:100vw; 
    height:100vh; 
    background: #000;
  }
  video { 
    width:100%; 
    height:100%; 
    object-fit:cover; 
  }
  #overlay { 
    position:absolute; 
    top:20px; 
    left:20px; 
    right:20px;
    background:rgba(0,0,0,0.7); 
    padding:15px; 
    border-radius:12px; 
    font-size:16px; 
    line-height:1.4; 
    pointer-events:none; 
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
  }
  #controls { 
    position:absolute; 
    bottom:30px; 
    left:50%; 
    transform:translateX(-50%); 
    z-index:10; 
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  button#capture {
    background:#fff; 
    border:none; 
    width:70px; 
    height:70px; 
    border-radius:50%; 
    font-size:28px; 
    cursor:pointer;
    box-shadow:0 4px 20px rgba(0,0,0,0.4); 
    outline:none; 
    position:relative; 
    overflow:hidden;
    transition: all 0.2s ease;
  }
  button#capture:active {
    transform: scale(0.95);
  }
  button#capture:disabled { 
    opacity:0.5; 
    cursor:not-allowed; 
    transform: none !important;
  }

  /* Loading è½¬åœˆåŠ¨ç”» */
  #loadingOverlay {
    position:absolute; 
    top:0; 
    left:0; 
    width:100%; 
    height:100%; 
    background:rgba(0,0,0,0.85);
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    justify-content:center; 
    z-index:100;
    opacity:0; 
    pointer-events:none; 
    transition:opacity 0.3s;
  }
  #loadingOverlay.show { 
    opacity:1; 
    pointer-events:all; 
  }
  .spinner {
    width:50px; 
    height:50px; 
    border:4px solid #333; 
    border-top:4px solid #4CAF50; 
    border-radius:50%;
    animation:spin 1s linear infinite; 
    margin-bottom:20px;
  }
  @keyframes spin { 
    to { transform:rotate(360deg); } 
  }

  #status { 
    position:absolute; 
    top:50%; 
    left:0; 
    right:0; 
    text-align:center; 
    color:#4CAF50; 
    font-size:16px; 
    padding:0 20px; 
    z-index:10;
    transform: translateY(-50%);
    background: rgba(0,0,0,0.7);
    padding: 15px;
    margin: 20px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
  }

  .error-message {
    position: absolute;
    bottom: 180px;
    left: 20px;
    right: 20px;
    background: rgba(244,67,54,0.9);
    color: #fff;
    padding: 12px;
    border-radius: 10px;
    font-size: 14px;
    text-align: center;
  }
</style>
</head>
<body>
<div id="container">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas" style="display:none;"></canvas>

  <div id="overlay">
    <div id="time">è·å–æ—¶é—´ä¸­...</div>
    <div id="location">å‡†å¤‡è·å–ä½ç½®ä¿¡æ¯...</div>
  </div>

  <div id="status">å‡†å¤‡å¯åŠ¨æ‘„åƒå¤´...</div>

  <div id="controls">
    <button id="capture">ğŸ“¸</button>
  </div>

  <!-- é”™è¯¯æç¤º -->
  <div id="errorMessage" class="error-message" style="display:none;"></div>

  <!-- Loading åŠ¨ç”»å±‚ -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div style="font-size:16px; text-align:center;">æ­£åœ¨ä¸Šä¼ ç…§ç‰‡<br><small>è¯·å‹¿å…³é—­é¡µé¢</small></div>
  </div>
</div>

<script>
// ==================== é…ç½® ====================
const BACKEND_URL = "https://huiying888.onrender.com/upload";
const urlParams = new URLSearchParams(location.search);
const TARGET_CHAT_ID = urlParams.get('chatid');
// ===============================================

let stream = null;
let locationData = null;
let isUploading = false;

// æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
function showError(message) {
  const errorEl = document.getElementById('errorMessage');
  errorEl.textContent = message;
  errorEl.style.display = 'block';
  setTimeout(() => {
    errorEl.style.display = 'none';
  }, 5000);
}

// åˆå§‹åŒ–Telegram WebApp
function initTelegramApp() {
  if (window.Telegram?.WebApp) {
    Telegram.WebApp.setHeaderColor('#000000');
    Telegram.WebApp.setBackgroundColor('#000000');
    Telegram.WebApp.expand();
    Telegram.WebApp.disableVerticalSwipes();
  }
}

// å®æ—¶æ—¶é—´
function updateTime() {
  const now = new Date();
  document.getElementById('time').textContent = "ğŸ• " + now.toLocaleString('zh-CN', {hour12:false});
}
setInterval(updateTime, 1000);
updateTime();

// æ˜¾ç¤º/éšè— loading
function showLoading(show) {
  document.getElementById('loadingOverlay').classList.toggle('show', show);
}

// åˆå§‹åŒ–æ‘„åƒå¤´ - å¼ºåˆ¶ä½¿ç”¨åç½®æ‘„åƒå¤´
async function initCamera() {
  try {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
    
    document.getElementById('status').textContent = "å¯åŠ¨åç½®æ‘„åƒå¤´ä¸­...";
    
    // å…ˆå°è¯•ç²¾ç¡®åŒ¹é…åç½®æ‘„åƒå¤´
    let constraints = {
      video: {
        facingMode: { exact: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    
    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (exactError) {
      console.log('ç²¾ç¡®åç½®æ‘„åƒå¤´å¤±è´¥ï¼Œå°è¯•æ™®é€šæ¨¡å¼:', exactError);
      // å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•æ™®é€šç¯å¢ƒæ¨¡å¼
      constraints = {
        video: {
          facingMode: "environment",
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
    }
    
    document.getElementById('video').srcObject = stream;
    document.getElementById('status').textContent = "âœ… æ‘„åƒå¤´å°±ç»ªï¼Œç‚¹å‡»æ‹ç…§å¼€å§‹æ‰“å¡";
    return true;
  } catch (error) {
    console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', error);
    document.getElementById('status').textContent = "âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™";
    showError("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·å…è®¸æ‘„åƒå¤´æƒé™ååˆ·æ–°é¡µé¢");
    return false;
  }
}

// è·å–ä½ç½®ä¿¡æ¯
async function getLocation() {
  return new Promise((resolve) => {
    if (!navigator.geolocation) {
      resolve(null);
      return;
    }
    
    const options = {
      enableHighAccuracy: true,
      timeout: 8000,
      maximumAge: 0
    };
    
    const success = (position) => {
      const lat = position.coords.latitude.toFixed(6);
      const lng = position.coords.longitude.toFixed(6);
      const acc = Math.round(position.coords.accuracy);
      
      document.getElementById('location').innerHTML = 
        `ğŸ“ ${lat}, ${lng}<br>ç²¾åº¦: ${acc}ç±³`;
      
      if (acc > 50) {
        document.getElementById('location').innerHTML += 
          '<br><span style="color:#ff9800">âš ï¸ å®šä½ç²¾åº¦è¾ƒä½</span>';
      }
      
      resolve({ lat, lng, acc });
    };
    
    const error = (err) => {
      console.warn('å®šä½è·å–å¤±è´¥:', err);
      document.getElementById('location').textContent = "âŒ å®šä½è·å–å¤±è´¥";
      resolve(null);
    };
    
    navigator.geolocation.getCurrentPosition(success, error, options);
  });
}

// æµ‹è¯•åç«¯è¿æ¥
async function testBackendConnection() {
  try {
    const testUrl = new URL(BACKEND_URL);
    testUrl.searchParams.set('test', '1');
    
    const response = await fetch(testUrl, {
      method: 'GET',
      mode: 'cors'
    });
    
    return response.ok;
  } catch (error) {
    console.error('åç«¯è¿æ¥æµ‹è¯•å¤±è´¥:', error);
    return false;
  }
}

// ä¸Šä¼ ç…§ç‰‡åˆ°æœåŠ¡å™¨
async function uploadPhoto(blob, location) {
  const formData = new FormData();
  formData.append('photo', blob, 'daka.jpg');

  const url = new URL(BACKEND_URL);
  if (location) {
    url.searchParams.set('lat', location.lat);
    url.searchParams.set('lng', location.lng);
    url.searchParams.set('acc', location.acc);
  }
  url.searchParams.set('name', 'æ±‡ç›ˆç”¨æˆ·');
  url.searchParams.set('time', Date.now());
  if (TARGET_CHAT_ID) {
    url.searchParams.set('chatid', TARGET_CHAT_ID);
  }

  try {
    const response = await fetch(url, {
      method: 'POST',
      body: formData,
      mode: 'cors'
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('ä¸Šä¼ é”™è¯¯:', error);
    throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}`);
  }
}

// æ‹ç…§ä¸»é€»è¾‘
document.getElementById('capture').addEventListener('click', async () => {
  if (isUploading) return;
  
  isUploading = true;
  const btn = document.getElementById('capture');
  btn.disabled = true;
  showLoading(true);
  
  try {
    // ç¬¬ä¸€æ­¥ï¼šè·å–ä½ç½®
    document.getElementById('status').textContent = "è·å–ä½ç½®ä¿¡æ¯ä¸­...";
    locationData = await getLocation();
    
    // ç¬¬äºŒæ­¥ï¼šæ‹æ‘„ç…§ç‰‡
    document.getElementById('status').textContent = "æ‹æ‘„ç…§ç‰‡ä¸­...";
    
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // æ·»åŠ æ°´å°
    const now = new Date().toLocaleString('zh-CN', {hour12:false});
    const locationText = locationData 
      ? `ç»çº¬åº¦ï¼š${locationData.lat},${locationData.lng} ç²¾åº¦:${locationData.acc}m`
      : 'ä½ç½®ä¿¡æ¯è·å–å¤±è´¥';
    
    const text = `${now}\n${locationText}`;
    
    ctx.font = 'bold 32px Arial';
    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
    ctx.lineWidth = 6;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.textBaseline = 'bottom';
    ctx.textAlign = 'left';

    // å·¦ä¸‹è§’æ°´å°
    const x = 30;
    const y = canvas.height - 30;
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);

    // è½¬æ¢ä¸ºBlob
    document.getElementById('status').textContent = "å‡†å¤‡ä¸Šä¼ ç…§ç‰‡...";
    
    const blob = await new Promise(resolve => {
      canvas.toBlob(resolve, 'image/jpeg', 0.85);
    });
    
    // ç¬¬ä¸‰æ­¥ï¼šä¸Šä¼ ç…§ç‰‡
    document.getElementById('status').textContent = "ä¸Šä¼ ç…§ç‰‡ä¸­...";
    
    // å…ˆæµ‹è¯•åç«¯è¿æ¥
    const backendAvailable = await testBackendConnection();
    if (!backendAvailable) {
      throw new Error("åç«¯æœåŠ¡ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–è”ç³»ç®¡ç†å‘˜");
    }
    
    const result = await uploadPhoto(blob, locationData);
    
    if (result && result.code === 0) {
      document.getElementById('status').innerHTML = "âœ… æ‰“å¡æˆåŠŸï¼<br>3ç§’åè‡ªåŠ¨å…³é—­";
      if (window.Telegram?.WebApp?.close) {
        setTimeout(() => Telegram.WebApp.close(), 3000);
      }
    } else {
      throw new Error(result?.msg || 'æœåŠ¡å™¨è¿”å›é”™è¯¯');
    }
    
  } catch (error) {
    console.error('æ‰“å¡å¤±è´¥:', error);
    document.getElementById('status').textContent = "âŒ æ‰“å¡å¤±è´¥";
    
    // æ›´è¯¦ç»†çš„é”™è¯¯æç¤º
    let errorMsg = error.message;
    if (error.message.includes('Failed to fetch') || error.message.includes('Network')) {
      errorMsg = "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥:\n1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n2. åç«¯æœåŠ¡æ˜¯å¦è¿è¡Œ\n3. æ˜¯å¦è¢«é˜²ç«å¢™é˜»æŒ¡";
    } else if (error.message.includes('CORS')) {
      errorMsg = "è·¨åŸŸè®¿é—®è¢«é˜»æ­¢ï¼Œè¯·è”ç³»ç®¡ç†å‘˜æ£€æŸ¥åç«¯CORSé…ç½®";
    }
    
    showError(errorMsg);
    
    // é‡æ–°å¯ç”¨æŒ‰é’®
    btn.disabled = false;
    isUploading = false;
    showLoading(false);
  }
});

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
window.addEventListener('load', async () => {
  initTelegramApp();
  
  // ç›´æ¥å¯åŠ¨åç½®æ‘„åƒå¤´
  await initCamera();
  
  // é¢„è·å–ä½ç½®ï¼ˆä½†ä¸é˜»å¡ï¼‰
  getLocation().then(location => {
    locationData = location;
  });
});

// é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && !stream) {
    initCamera();
  }
});
</script>
</body>
</html>
